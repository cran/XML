<?xml version="1.0"?>
<!DOCTYPE RHelp SYSTEM "RSHelp.dtd">

<RSHelp>
<name>xmlTreeParse</name>
<title>XML Parser</title>
<description>
 Parses an XML file or string, and generates an R 
 structure representing the XML tree.
</description>
<usage>
<name>xmlTreeParse</name>
<arg>file</arg>,
<arg>ignoreBlanks<defaultValue>T</defaultValue></arg>,
<arg>handlers<defaultValue>NULL</defaultValue></arg>, 
<arg>replaceEntities<defaultValue>F</defaultValue></arg>,
<arg>asText<defaultValue>F</defaultValue></arg>, 
<arg>trim<defaultValue>T</defaultValue></arg>,
<arg>validate<defaultValue>F</defaultValue></arg>, 
<arg>getDTD<defaultValue>F</defaultValue></arg>, 
<arg>isURL<defaultValue>F</defaultValue></arg> 
</usage>

<arguments>
<arg>
 <name>file</name><description>The name of the file containing the XML contents.
This can contain \~ which is expanded to the user's
home directory.
It can also be a URL. See \code{isURL}.
Additionally, the file can be compressed (gzip)
and is read directly without the user having
to de-compress (gunzip) it.
</description>
</arg>
 <arg><name>ignoreBlanks</name><description>logical value indicating whether
text elements made up entirely of white space should be included
in the resulting `tree'. </description></arg>
<arg><name>handlers</name><description>Optional collection of functions
  used to map the different XML nodes to R
  objects. This is a named list of functions,
   and a closure can be used to provide local data.
</description></arg>
<arg><name>replaceEntities</name><description>
   logical value indicating whether to substitute entity references
    with their text directly. This should be left as False.
    The text still appears as the value of the node, but there
    is more information about its source, allowing the parse to be reversed
    with full reference information.
</description></arg>
<arg><name>asText</name><description>
logical value indicating that the first argument,
    `file', 
     should be treated as the XML text to parse, not the name of 
     a file. This allows the contents of documents to be retrieved 
     from different sources (e.g. HTTP servers, XML-RPC, etc.) and still
     use this parser.
</description></arg>
<arg><name>trim</name><description>
  whether to strip white space from the beginning and end of text strings.
</description></arg>
<arg><name>validate</name><description>
logical indicating whether to use a validating parser or not, or in other words
check the contents against the DTD specification. If this is true, warning
messages will be displayed about errors in the DTD and/or document, but the parsing 
will proceed except for the presence of terminal errors.
</description></arg>
<arg><name>getDTD</name><description>
logical flag indicating whether the DTD (both internal and external)
should be returned along with the document nodes. This changes the 
return type.
</description></arg>
<arg><name>isURL</name><description>
   indicates whether the \code{file}  argument refers to a URL
  (accessible via ftp or http) or a regular file on the system.
  If \code{asText} is TRUE, this should not be specified.
  The function attempts to determine whether the 
  data source is a URL by using \code{\link{grep}}
  to look for http or ftp at the start of the string.
  The libxml parser handles the connection to servers,
  not the R facilities (e.g. \code{\link{scan.url}}).
</description></arg>
</arguments>
<details>
 The \code{handlers} argument is used similarly
to those specifid in \link{xmlEventParse}.
 When an XML tag (element) is processed,
  we look for a function in this collection 
  with the same name as the tag's name. 
  If this is not found, we look for one named
  startElement. If this is not found, we use the default
  built in converter.
  The same works for comments, entity references, etc.
 The default entries should be named
\code{comment}, \code{startElement},
\code{externalEntity},
\code{processingInstruction}
\code{text}.
They should take the XMLnode as their first argument.
In the future, other information may be passed via \dots,
for example, the depth in the tree, etc.
Specifically, the second argument will be the parent node into which they
are being added, but this is not currently implemented,
so should have a default value (\code{NULL}).

Each of these functions can return arbitrary values that are then
entered into the tree in place of the default node passed to the
function as the first argument.  This allows the caller to generate
the nodes of the resulting document tree exactly as they wish.  If the
function returns \code{NULL}, in the future, we will drop this node
from the tree.
</details>

<value>
By default, an object of class XML doc is returned,
 which contains fields/slots named  \code{file}, \code{version} and \code{children}.

<valueElements>
  <valueElement><id>file</id><description>The (expanded) name of the file
 containing the XML.</description></valueElement>
  <valueElement><id>version</id><description>A string identifying the 
 version of XML used by the document.</description></valueElement>
  <valueElement><id>children</id><description>
 A list of the XML nodes at the top of the document.
 Each of these is of class \code{XMLNode}.
 These are made up of 4 fields.
 <valueElements>
   <valueElement>
        <id>\code{name}</id>
        <description>The name of the element.</description>
   </valueElement>

   <valueElement><id>attributes</id><description>
      For regular elements, a named list
     of XML attributes converted from the 
       &lt;tag x="1" y="abc"&gt;
       </description>
    </valueElement>

   <valueElement><id>children</id><description>List of
   sub-nodes.</description>
    </valueElement>

   <valueElement><id>value</id><description>Used only for text
   entries.
    </description></valueElement>
 </valueElements>
Some nodes specializations of \code{XMLNode}, such as 
 \code{XMLComment}, \code{XMLProcessingInstruction},
 \code{XMLEntityRef} are used.
</description>
</valueElement>
</valueElements>
If the value of the argument getDTD is TRUE, the return value is a
list of length 2.  The first element is as the document as described
above.  The second element is a list containing the external and
internal DTDs. Each of these contains 2 lists - one for elements
and another for entities. See \code{\link{parseDTD}}.
</value>

<references>
<url>http://xmlsoft.org</url>, 
<url>http://www.w3.org/xml</url>
</references>

<author>Duncan Temple Lang</author>

<notes>
<note>Make sure that the necessary 3rd party libraries are available.
</note>
</notes>

<seealso>
 <see><link>xmlEventParse</link></see> 
</seealso>

<examples>
<example>
<![CDATA[
 fileName <- system.file("data/test.xml", pkg="XML")
   # parse the document and return it in its standard format.
 xmlTreeParse(fileName)
]]>
</example>

<example>
<description>
  parse the document, discarding comments.
</description>
<![CDATA[
 xmlTreeParse(fileName, handlers=list("comment"=function(x, parent){NULL}))

 invisible(xmlTreeParse(fileName,
            handlers=list(entity=function(x) {
                                    cat("In entity",x$name, x$value,"\n")}
                                  )
                          )
         )
]]>
</example>

<example>
<![CDATA[
 # Parse some XML text.
 # Read the text from the file
 xmlText <- paste(scan(fileName, what="",sep="\n"),"\n", collapse="\n")
 xmlTreeParse(xmlText, asText=T)

 # Read a MathML document and convert each node
 # so that the primary class is 
 #   <name of tag>MathML
 # so that we can use method  dispatching when processing
 # it rather than conditional statements on the tag name.
 # See plotMathML() in examples/.
 fileName <- system.file("data/mathml.xml",pkg="XML")
m <- xmlTreeParse(fileName, 
                  handlers=list(startElement=function(node){
                              cname <- paste(xmlName(node),"MathML",sep="",collapse="")
                              class(node) <- c(cname, class(node)); 
                              node
                }))
]]>
</example>

<example dontRun="T">
<![CDATA[
 # Parse an XML document directly from a URL.
 # Requires Internet access.
 xmlTreeParse("http://www.omegahat.org/Scripts/Data/mtcars.xml", asText=T)
]]>
</example>


<example>
<description>
 In this example, we extract <u>just</u> the names of the
 variables in the mtcars.xml file. 
 The names are the contents of the &lt;variable&gt;
 tags. We discard all other tags by returning NULL
 from the startElement handler.
<P/>
 We cumulate the names of variables in a character
 vector named `vars'.
 We define this within a closure and define the 
 variable function within that closure so that it
 will be invoked when the parser encounters a &lt;variable&gt;
 tag.
 This is called with 2 arguments: the XMLNode object (containing
 its children) and the list of attributes.
 We get the variable name via call to xmlValue().
<P/>
 Note that we define the closure function in the call and then 
 create an instance of it by calling it directly as
  <code>(function() {...})()</code>
<P/>
 Note that we can get the names by parsing
 in the usual manner and the entire document and then executing
 <code>xmlSApply(xmlRoot(doc)[[1]], function(x) xmlValue(x[[1]]))</code>
 which is simpler but is more costly in terms of memory.
</description>
<![CDATA[
 fileName <- system.file("data/mtcars.xml")
 doc <- xmlTreeParse(fileName,  handlers = (function() { 
                                 vars <- character(0) ;
                                list(variable=function(x, attrs) { 
                                                vars <<- c(vars, xmlValue(x[[1]])); 
                                                NULL}, 
                                     startElement=function(x,attr){
                                                   NULL
                                                  }, 
                                     names = function() {
                                                 vars
                                             }
                                    )
                               })()
                     )

]]>
</example>
</examples>

<keywords>
<keyword>file</keyword>
<keyword>XML</keyword>
<keyword>DTD</keyword>
</keywords>
</RSHelp>
