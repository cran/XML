<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>A Short Introduction to the XML package for R</title><link rel="stylesheet" href="/Users/duncan/Classes/StatComputing/IDynDocs/inst/CSS/OmegaTech.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"></meta></head><body><div class="article" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="id1289503"></a>A Short Introduction to the <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="s:package(%22XML%22)">XML</a></i> package for R</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Duncan</span> <span class="surname">Temple Lang</span></h3><div class="affiliation"><span class="orgname">UC Davis<br></br></span> <span class="orgdiv">Dept. of Statistics<br></br></span></div></div></div></div><hr></hr></div><div class="section" lang="en"><div class="titlepage"></div><p>
This is intended to be a short document that gets you started with the
R package <a xmlns:omg="http://www.omegahat.org" xmlns:rwx="http://www.omegahat.org/RwxWidgets" xmlns="" href="http://www.omegahat.org/RSXML">XML</a>.  There are two main things that one
does with the <a xmlns:omg="http://www.omegahat.org" xmlns:rwx="http://www.omegahat.org/RwxWidgets" xmlns="" href="http://www.omegahat.org/RSXML">XML</a> package: read XML documents and
create XML documents.  We'll start with the first of these.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id1392946"></a>Reading XML</h2></div></div></div><p>
To parse an XML document, you can use
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlInternalTreeParse.html">xmlInternalTreeParse()
  </a></i> or <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlTreeParse.html">xmlTreeParse()
  </a></i>
(with <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns="">useInternalNodes</i> specified as <i xmlns:rs="http://www.omegahat.org/RS" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns=""><code>TRUE</code></i> or
<i xmlns:rs="http://www.omegahat.org/RS" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns=""><code>FALSE</code></i>) or <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlEventParse.html">xmlEventParse()
  </a></i>.  If you are dealing
with HTML content which is frequently malformed (i.e. nodes not
terminated, attributes not quoted, etc.), you can use
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="htmlTreeParse.html">htmlTreeParse()
  </a></i>.  You can give these functions the name
of a file, a URL (HTTP or FTP) or XML text that you have previously
created or read from a file.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id1392980"></a>Tree/DOM-based parsing</h3></div></div></div><p>
If you are working with small to moderately sized XML files, it is
easiest to use <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlInternalTreeParse.html">xmlInternalTreeParse()
  </a></i> to first read the
XML tree into memory.
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
#"http://www.omegahat.org/RSXML/index.html"
doc = xmlInternalTreeParse("Install/Web/index.html.in")
</pre></div>
<p>
Then you can traverse the tree looking for the
information you want and putting it into different forms.  There are
two ways to do this iteration.  One is to recursively "walk" the tree
yourself by starting at the root node and processing it, and then
process each child node in the same manner, working on its name and
attributes and then its children, and so on.  In order to collect the
information at different levels into an data structure, it is often
convenient to use global variables. This works for interactive
computations. When writing functions for this, make certain to use
closures/lexical scoping to obtain non-local variables that are not
truly global.
</p><p>
Many people find recursion confusing, and when coupled with the need
for non-local variables and mutable state, a different approach can be
welcome.  If we know what parts of the tree that we are interested in,
then it is convenient to just fetch them, process them and discard
them to move on to the other pieces.  XPath is an XML technology that
provides a language for accessing subsets of an XML tree.  It allows
us to express things such as "find me all nodes named a" or "find me
all nodes name a that have no attribute named b" or "nodes a that have
an attribute b equal to 'bob'" or "find me all nodes a which have c as
an ancestor node".  It has a similar feeling to R's subsetting
capabilities and works for trees rather than vectors and data frames.
It is also very powerful and efficient. But it takes a little time to learn.
Some decent tutorials are available on the Web
(e.g. <a class="ulink" href="http://www.zvon.org/xxl/XPathTutorial/General/examples.html" target="_top">Zvon</a>
and <a class="ulink" href="http://www.w3schools.com/xpath" target="_top">w3schools</a>)
and there are books that cover this subject,
e.g. [<a href="#XMLinNutshell" class="biblioref" title="[XML in a Nutshell]"><abbr class="abbrev">XML in a Nutshell</abbr></a>], 
[<a href="#XPathXPointer" class="biblioref" title="[XPathXPointer]">XPathXPointer</a>].
</p><p>
The XPath functions  in the <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="s:package(%22XML%22)">XML</a></i> package are 
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="getNodeSet.html">getNodeSet()
  </a></i> and  <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xpathApply.html">xpathApply()
  </a></i>.
Basically, you specify the document
returned from <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlInternalTreeParse.html">xmlInternalTreeParse()
  </a></i>
and the XPath expression to identify the nodes.
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="getNodeSet.html">getNodeSet()
  </a></i> returns a list of the matching nodes.
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xpathApply.html">xpathApply()
  </a></i> is used to apply a function to each of those nodes,
e.g. find  nodes named "a anywhere in the tree that have an "href"
attribute and get the value of that attribute
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
src = xpathApply(doc, "//a[@href]", xmlGetAttr, "href")
</pre></div>
<p>
</p><p>
Of course, once we have the nodes of interest, we need to be able to
extract their information.  There are several functions to do this:
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlName.html">xmlName()
  </a></i>, <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlAttrs.html">xmlAttrs()
  </a></i>, <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlGetAttr.html">xmlGetAttr()
  </a></i>, 
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlChildren.html">xmlChildren()
  </a></i> and <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlValue.html">xmlValue()
  </a></i>.  <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlName.html">xmlName()
  </a></i>
gets the name of the node/element.  <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlAttrs.html">xmlAttrs()
  </a></i> returns
all the attribute name-value pairs as a character vector while
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlGetAttr.html">xmlGetAttr()
  </a></i> is used to query the value of a single
attribute with facilities for providing a default value if it is not
present and converting it if it is.
We tend to use <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlGetAttr.html">xmlGetAttr()
  </a></i> as we typically know
which attributes we are looking for. <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlAttrs.html">xmlAttrs()
  </a></i>
is used when doing general/meta- computations.
</p><p>
That's essentially all the information that is available directly from
the node. 
Other information is available from the child nodes.
If you are dealing with a "simple" node that contains
no XML child nodes but simply text, e.g.
</p><pre class="programlisting">
&lt;emphasis&gt;text to be emphasized&lt;/emphasis&gt;
</pre><p>
then the text is actually a child node.
We can deal with it in the way we deal with arbitrary children nodes,
but the function <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlValue.html">xmlValue()
  </a></i> is convenient
for retrieving the text value of a node.
So we could get the string "text to be emphasized" via the call
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
 xmlValue(node)
</pre></div>
<p>
assuming <b xmlns:rs="http://www.omegahat.org/RS" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns="" class="$">node</b> referred to the node.
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlValue.html">xmlValue()
  </a></i> works on arbitrary nodes, not just simple text nodes
and operates recursively.
</p><p>
The child nodes are accessed by
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlChildren.html">xmlChildren()
  </a></i> and each of these is also a node and so
amenable to <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlName.html">xmlName()
  </a></i>, <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlAttrs.html">xmlAttrs()
  </a></i> and
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlGetAttr.html">xmlGetAttr()
  </a></i>.
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlChildren.html">xmlChildren()
  </a></i> gives you a regular R
list containing all of the child nodes.
You can then access  individual elements or subsets
of these using regular R subscripting.
 For example,
suppose we have a node with name "A" and it has children with node names
"X", "Y" and "Z", and "X", "Y" and "Z",

i.e.
<a id="XYZ-nodes"></a></p><pre class="programlisting">
&lt;A&gt;
  &lt;X/&gt;
  &lt;Y/&gt;
  &lt;Z/&gt;
  &lt;X/&gt;
  &lt;Y/&gt;
&lt;/A&gt;
</pre><p>
Then we can get the first or the last two children with 
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
xmlChildren(node)[[1]]
xmlChildren(node)[2:3]
</pre></div>
<p>
We can determine how many children a node has with
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
length(xmlChildren(node))
</pre></div>
<p>
or
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
xmlSize(node)
</pre></div>
<p>
</p><p>

You can also use names corresponding to the node names. 
Then we could get all the nodes
named "Y" and "Z" with
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
xmlChildren(node)[c("Y", "Z")]
</pre></div>
<p>
</p><p>

You can also index the children directly without having to use
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlChildren.html">xmlChildren()
  </a></i> to get the list first.
For example, we can do the subsetting above more conveniently
as 
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
node[1:3]
</pre></div>
<p>
Similarly, we can use names directly
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
 node[c("Y", "Z")]
</pre></div>
<p>
</p><p>
We frequently apply the same operation on all the children, 
for example, get their class or get an attribute of each.
We can do this as
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
sapply(xmlChildren(node), xmlGetAttr, "id")
</pre></div>
<p>
but again, we can do it more tersely with
either of the functions <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlApply.html">xmlApply()
  </a></i>
and <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlSApply.html">xmlSApply()
  </a></i>.
So the above becomes
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
xmlSApply(node, xmlGetAttr, "id")
</pre></div>
<p>
</p><p>
If you us <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlInternalTreeParse.html">xmlInternalTreeParse()
  </a></i> (or
<code xmlns:rs="http://www.omegahat.org/RS" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns="" class="Sexpression">xmlTreeParse(.., useInternalNodes = TRUE)</code>), you will
end up with "internal" nodes that are references to the C data
structures representing nodes. Otherwise, you will end up with XML
nodes represented as lists of lists in R.  With the internal nodes,
you can "walk" the tree by going up and sideways, not just down
through the children.
The function <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlParent.html">xmlParent()
  </a></i> gets the parent node
of an XML node, or returns <i xmlns:rs="http://www.omegahat.org/RS" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns=""><code>NULL</code></i>.
You can use this to iteratively walk to the top of the tree
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
 while(!is.null(node)) {
   node = xmlParent(node)
 }
</pre></div>
<p>
Given a node, we can also use <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="getSibling.html">getSibling()
  </a></i> to move
sideways.  This gets the next sibling to right or left of a particular
node in the list if children.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id1393269"></a>SAX &amp; Event-driven parsing</h3></div></div></div><p>
If you have a very large XML file, you probably want to use the
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlEventParse.html">xmlEventParse()
  </a></i> function to parse the file.  This is
quite low-level and you have to provide functions that are invoked
when the parser encounters events within the XML stream such as the
start of a node, the end of a node, a text chunk, a processing
instruction, and so on.  There is no tree so you can't find the
children of a node directly but your code has to remember where it is
based on the open and close node event so that one can understand the
hierarchy.  This is a state machine and a quite different style of
programming than that involved in pulling information out of a tree.
</p><p>
If you are lucky enough to be interested in reasonably-sized subsets
of the tree, then you can use "branches" to make things a little
simpler. Otherwise, you have to define handler functions for
processing start and end of nodes, and maintain the state of where the
parser is to make sense of the information.  This is the most
efficient way to read an XML file, but is not the simplest. So we tend
to try to work with <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlTreeParse.html">xmlTreeParse()
  </a></i> unless we know that
we have to deal with large data files.
</p><p>
SAX is very memory efficient as it doesn't build the tree.  However,
for quick results, you can try use
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlInternalTreeParse.html">xmlInternalTreeParse()
  </a></i> and XPath queries to get results
even on very large files.  If the tree can be read into memory, it can
be queried efficiently. So it is always worth a try.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id1393311"></a>Creating XML</h2></div></div></div><p>
We often want to generate XML.
For example, we want to create an HTML document to view in a browser.
Or we want to generate input  for Google Earth to display.
Or we want to create XML nodes for dynamic documents.
Again, the <a xmlns:omg="http://www.omegahat.org" xmlns:rwx="http://www.omegahat.org/RwxWidgets" xmlns="" href="http://www.omegahat.org/RSXML">XML</a> package provides several different
ways to go about doing this.
We'll focus on using internal nodes directly.
There are higher-level functions to aid in this also,
and alternative representations using R-level objects rather than C objects.
</p><p>
To create a regular node, we use <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="newXMLNode.html">newXMLNode()
  </a></i>.  This
takes the name of the XML element/node, e.g. "img" for an image in
HTML.  Attributes are given by the <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns="">attrs</i> argument.  And
children can be added via the <i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns="">...</i> mechanism.
So for example, we can create the tree we discussed <a class="xref" href="#XYZ-nodes">'simple tree'</a> above
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns="">
<a class="r-code-chunk-name" name="make-nodes">make-nodes</a><pre class="rcode">
node = newXMLNode("A")
sapply(c("X", "Y", "Z", "X", "Y"), 
        newXMLNode, parent = node)
cat(saveXML(node))
</pre>
</div>
<p>
</p><p>
W can change a odes attributes using 
<i xmlns:cpp="http://www.cplusplus.org" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns=""><a href="xmlAttrs.html">xmlAttrs()
  </a></i> as in
</p><div xmlns:omegahat="http://www.omegahat.org" xmlns:docbook="http://docbook.org/ns/docbook" xmlns=""><pre class="rcode">
xmlAttrs(node)["src"]  = "http://www.omegahat.org"
</pre></div>
<p>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id1393370"></a>Further Topics</h2></div></div></div><p>We haven't mentioned name spaces, DTDs, schema,
XSL or any of the advanced aspects of XPath.</p></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a id="id1393381"></a>Bibliography</h2></div></div></div><div class="biblioentry"><a id="XMLinNutshell"></a><p>[<abbr class="abbrev">XML in a Nutshell</abbr>] <span class="biblioset"><i>XML in a Nutshell</i>. <span class="subtitle">A Desktop Quick Reference. </span><span class="publisher"><span class="publishername">O'Reilly &amp; Associates, Inc.. </span></span><span class="author"><span class="firstname">Elliotte Rusty</span> <span class="surname">Harold</span>. </span><span class="author"><span class="firstname">W. Scott</span> <span class="surname">Means</span>. </span><span class="edition">third. </span><span class="date">2004. </span></span></p></div><div class="biblioentry"><a id="XPathXPointer"></a><p>[XPathXPointer] <span class="biblioset"><i>XPath and XPointer</i>. <span class="publisher"><span class="publishername">O'Reilly &amp; Associates, Inc.. </span></span><span class="author"><span class="firstname">John E.</span> <span class="surname">Simpson</span>. </span></span></p></div><span class="date">2002</span></div></div></body></html>
